k 和p算法已经Dijkstra都是最小生成树算法
三者都是怎对无向图的，但是最后的一个不能有累加权重小于零的环

k算法是 从最小边 开始搭建，如果以此搭建没有形成环就要否则不要这个边（判断添加边后会形成环？
可以使用并查集完成判断，比如判读此边的两个node之前在不在同一个集合中）

P算法是从点出发的，访问第一个点是比如head,就是解锁与head相关的边，然后选择边权重最小的toNode节点作为下个路径，但是这个
toNode不能是已经使用过的，所以需要个set来完成过滤

Dijkstra算法首先是从head节点开始，然后给head到图中每个节点设置访问路径成本（权值大小）
只能适用于形成环的权重值累加必须大于零
 比如head 到head为零 到其他节点为正无穷 ---初始化阶段
 后面阶段就是盖过成本，锁住然后类推  ---此算法可以再次看视频


K算法要点：
一个操作<node>泛型的集合--并查集
一个优先队列<edge> 
遍历队列  比较 from to是否在集合钟，不在res.add(edge) + union<from,to>


Dijkstra和p,k算法的区别就是：
Dijkstra必须有个出发点然后生成的最小生成树
而k,p算法是不规定出发点而形成的最小生成树


